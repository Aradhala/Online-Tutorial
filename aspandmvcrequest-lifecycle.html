<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sri IT Solutions</title>
    <!-- CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
    <link href="css/font-awesome.min.css" rel="stylesheet" media="screen">
    <link href="css/animate.min.css" rel="stylesheet" media="screen">
    <link href="css/lightbox.css" rel="stylesheet" media="screen">
    <link href="css/syntax/shCore.css" rel="stylesheet"  media="screen">
    <link href="css/syntax/shThemeDefault.css" rel="stylesheet"  media="screen">

    <link href="css/style.css" rel="stylesheet" media="screen" title="default">
    <link href="css/color-default.css" rel="stylesheet" media="screen" title="default">
    <link href="css/width-full.css" rel="stylesheet" media="screen" title="default">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="js/html5shiv.js"></script>
        <script src="js/respond.min.js"></script>
    <![endif]-->
	<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83848353-1', 'auto');
  ga('send', 'pageview');

</script>

</head>

<body>

    <div class="boxed animated fadeIn animation-delay-5">

        <header id="header" class="hidden-xs">
            <div class="container">
                <div id="header-title">
                    <h1 class="animated fadeInDown"><a href="index.html">
                      <img style="width: 200px;height: 150px;padding: 0px;margin: -35px;" src="img/Logo1_new.jpg"/></a></h1>

                </div>

                <div id="social-header" class="hidden-xs">
                    <a href="#" class="social-icon soc-twitter animated fadeInDown animation-delay-1"><i class="fa fa-twitter"></i></a>
                    <a href="#" class="social-icon soc-google-plus animated fadeInDown animation-delay-2"><i class="fa fa-google-plus"></i></a>
                    <a href="#" class="social-icon soc-facebook animated fadeInDown animation-delay-3"><i class="fa fa-facebook"></i></a>
                    <a href="#" class="social-icon soc-instagram animated fadeInDown animation-delay-4"><i class="fa fa-instagram"></i></a>
                    <a href="#" class="social-icon soc-pinterest animated fadeInDown animation-delay-5"><i class="fa fa-pinterest"></i></a>
                    <a href="#" class="social-icon soc-linkedin animated fadeInDown animation-delay-6"><i class="fa fa-linkedin"></i></a>
                    <a href="#" class="social-icon soc-github animated fadeInDown animation-delay-7"><i class="fa fa-github"></i></a>
                </div>


            </div> <!-- container -->
        </header> <!-- header -->

        <nav class="navbar navbar-static-top navbar-mind" role="navigation">
            <div class="container">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="index.html">
                      <img style="width: 200px;height: 150px;padding: 0px;margin: -35px;" src="img/Logo1_new.jpg"/></a>

                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-mind-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <i class="fa fa-bars fa-inverse"></i>
                    </button>
                </div>

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse navbar-mind-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="index.html">Home</a></li>
						<li><a href="about.html">About</a></li>
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Courses<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="csharp.html">C#</a></li>
                                <li><a href="asp.html">ASP.NET</a></li>
                                <li><a href="ado.html">ADO.NET</a></li>
                                <li><a href="mvc.html">MVC</a></li>
								<li><a href="javascript.html">Javascript</a></li>
                            </ul>
                        </li> <!-- dropdown -->
						<li><a href="batches.html"> Batches</a></li>
						<li class="dropdown active">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Blog<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li class=" active"><a href="aspandmvcrequest-lifecycle.html">ASP.NET & MVC Request Life Cycle</a></li>
								<li><a href="mvchistoryandevolution.html">MVC – History & Folder Structure</a></li>
								<li><a href="mvcproject-templates.html">MVC – Project Templates</a></li>
								<li><a href="mvcforms.html">MVC – Forms</a></li>
								<li><a href="mvc-controllers.html">MVC – Controllers</a></li>

                            </ul>
                        </li> <!-- dropdown -->
						<li><a href="contact.html">Contact Us</a></li>

                    </ul> <!-- nav nabvar-nav -->

                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="login.html">Login</a></li>
                        <li><a href="signin.php">Register</a></li>
                    </ul> <!-- nav nabvar-nav -->
                </div><!-- navbar-collapse -->
            </div> <!-- container -->
        </nav> <!-- navbar navbar-default -->

        <header class="wrap-title">
            <div class="container">
                <h1 class="page-title">Blog</h1>

                <ol class="breadcrumb hidden-xs">
                    <li><a href="#">Home</a></li>
                    <li class="active">ASP.NET & MVC Request Life Cycle</li>
                </ol>
            </div>
        </header>

        <div class="container">
            <div class="row">
				<div class="col-xs-12">
                    <p class="lead lead-lg text-center animated bounceInLeft animation-delay-12"> <strong>Introduction to ASP.NET & MVC Request Life Cycle</strong></p>
                </div>
                <div class="col-xs-12">
					<h3>ASP.NET Request-Response Architecture</h3>
					<ul>
						<li>ASP.NET MVC is a framework for developing dynamic Web applications using the .NET Framework.</li>
						<li>Prior to ASP.NET MVC, dynamic Web applications based on the .NET Framework were developed using ASP. NET Web pages and ASP.NET Web Forms.</li>
						<li>ASP.NET is a server-side technology that enables you to create dynamic Web applications using advanced features, such as simplicity, security, and scalability, which are based on the .NET Framework.</li>
						<li>ASP.NET applications comprises of .aspx Web pages that combine both client-side and server-side scripts to build dynamic Web sites.</li>
						<li>When request come from client to the server a lot of operation is performed before sending response to the client. This is all about how IIS Process the request.</li>
					</ul>
					<h3>What is Web Server?</h3>
					<ul>
						<li>When we run our ASP.NET Web Application from visual studio IDE, VS Integrated ASP.NET Engine is responsible to execute all kind of asp.net requests and responses.</li>
						<li>The process name is “WebDev.WebServer.Exe” which actually take care of all request and response of a web application which is running from Visual Studio IDE.</li>
						<li>Now, the name “Web Server” comes into picture when we want to host the application on a centralized location and wanted to access from many locations.</li>
						<li>Web server is responsible for handle all the requests that are coming from clients, process them and provide the responses.</li>
					</ul>
					<p class="text-center"><img class="img-responsive text-center" src="img/blog/img1.png"/></p>
					<h3>What is IIS?</h3>
					<ul>
						<li>IIS (Internet Information Server) is one of the most powerful web servers from Microsoft that is used to host your ASP.NET Web application.</li>
						<li>IIS has its own ASP.NET Process Engine to handle the ASP.NET request. So, when a request comes from client to server, IIS takes that request and process it and send response back to clients.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img2.png" title="IIS Request Response"/></p>
					<h3>Worker Process</h3>
					<ul>
						<li>Worker Process (w3wp.exe) runs the ASP.Net application in IIS. This process is responsible to manage all the request and response that are coming from client system.</li>
						<li>ll the ASP.Net functionality runs under the scope of worker process.  When a request comes to the server from a client worker process is responsible to generate the request and response.</li>
						<li>In a single word we can say worker process is the heart of ASP.NET Web Application which runs on IIS.</li>
						<li><strong>Application Pool:</strong> Application pool is the container of worker process.  An application pool is used to separate sets of IIS worker processes that share the same configuration.</li>
						<li>An application pool enables a better security, reliability, and availability for any web application.  </li>
						<li>The worker process serves as the process boundary that separates each application pool so that when one worker process or application is having an issue or recycles, other applications or worker processes are not affected.</li>
						<li>This makes sure that a particular web application doesn’t not impact other web application as they are configured into different application pools.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img3.png" title="Worker Process"/></p>
					<ul>
						<li>Application Pool with multiple worker process is called “Web Garden”.</li>
						<li>If we look into the IIS 6.0 Architecture, we can divided them into Two Layer
							<ul>
								<li>Kernel Mode</li>
								<li>User Mode</li>
							</ul>
						</li>
						<li>Now, Kernel mode is introduced with IIS 6.0, which contains the HTTP.SYS.  So whenever a request comes from Client to Server, it will hit HTTP.SYS First.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img4.png" title="HTTP.SYS"/></p>
					<ul>
						<li>Now, HTTP.SYS is Responsible for pass the request to particular Application pool. Now here is one question, How HTTP.SYS comes to know where to send the request?  This is not a random pickup.</li>
						<li>Whenever we create a new Application Pool, the ID of the Application Pool is being generated and it’s registered with the HTTP.SYS.</li>
						<li>So whenever HTTP.SYS Received the request from any web application, it checks for the Application Pool and based on the application pool it send the request.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img5.png" title="Web Applications & HTTP.SYS"/></p>
					<ul>
						<li>Till now, Client Requested for some information and request came to the Kernel level of IIS means at HTTP.SYS. HTTP.SYS has been identified the name of the application pool where to send.</li>
						<li>In User Level of IIS, we have Web Admin Services (WAS) which takes the request from HTTP.SYS and pass it to the respective application pool.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img6.png" title="User Level of IIS"/></p>
					<ul>
						<li>When Application pool receives the request, it simply pass the request to worker process (w3wp.exe).</li>
						<li>The worker process “w3wp.exe” looks up the URL of the request in order to load the correct ISAPI extension. ISAPI extensions are the IIS way to handle requests for different resources.</li>
						<li>Once ASP.NET is installed, it installs its own ISAPI extension (aspnet_isapi.dll) and adds the mapping into IIS.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img7.png" title="User & Kernel Level of IIS"/></p>
					<ul>
						<li>When Worker process loads the aspnet_isapi.dll, it starts an HTTPRuntime, which is the entry point of an application. HTTPRuntime is a class which calls the ProcessRequest method to start Processing.</li>
						<li>When this methods called, a new instance of HTTPContext is been created.  This is accessible using HTTPContext.Current properties.</li>
						<li>This object still remains alive during life time of object request.  Using HttpContext.Current we can access some other objects like Request, Response, Session etc.</li>
						<li>After that HttpRuntime load an HttpApplication object with the help of HttpApplicationFactory class.. Each and every request should pass through the corresponding HTTPModule to reach to HTTPHandler, this list of module are configured by the HTTPApplication.</li>
						<li>Now, the concept comes called “HTTPPipeline”. It is called a pipeline because it contains a set of HttpModules (For Both Web.config and Machine.config level) that intercept the request on its way to the HttpHandler.</li>
						<li>HTTPModules are classes that have access to the incoming request. We can also create our own HTTPModule if we need to handle anything during upcoming request and response.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img8.png" title=""/></p>
					<ul>
						<li>HTTP Handlers are the endpoints in the HTTP pipeline. All request that are passing through the HTTPModule should reached to HTTPHandler.  </li>
						<li>Then HTTP Handler generates the output for the requested resource. So, when we requesting for any aspx web pages,   it returns the corresponding HTML output.</li>
						<li>All the request now passes from httpModule to respective HTTPHandler then method and the ASP.NET Page life cycle starts.  This ends the IIS Request processing and starts the ASP.NET Page Lifecycle.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img9.png" title=""/></p>
					<h3>Conclusion</h3>
					<ul>
						<li>When client request for some information from a web server, request first reaches to HTTP.SYS of IIS. HTTP.SYS then sends the request to respective Application Pool.</li>
						<li>Application Pool then forward the request to worker process to load the ISAPI Extension which will create an HTTPRuntime Object to Process the request via HTTPModule and HTTPHanlder. After that the ASP.NET Page Lifecycle event starts.</li>
					</ul>

					<h3>MVC Request Life Cycle</h3>
					<ul>
						<li>Life cycle of MVC request is a series of steps involved in processing client request. Regardless of technology and platforms almost all the web frameworks have one or other type of Request life cycle and MVC is no different.</li>
						<li>Understanding the life cycle of any web framework helps better leverage the features for processing requests.</li>
						<li>The entry point of MVC Request life cycle is URL Routing module, the incoming request from IIS pipeline is handed over to URL Routing module which analyses the request and looks up Routing table to figure out which controller the incoming request maps to.</li>
						<li>Routing Table is a static container of routes defined in MVC application with corresponding controller action mapping.</li>
						<li>If the route is found in the routing table MVCRouteHandler executes and brings the instance of MVCHttpHandler. Together they act as a gateway into the MVC Framework.  </li>
						<li>MVC handler begins initializing and executing controller. The MVCHttpHandler also takes of converting route data into concrete controller that is capable of serving the request.</li>
						<li>MVC handler does all this with the help of MVC Controller factory and activator which are responsible for creating an instance of the controller.</li>
						<li>This is also the place where the Dependency Injection is performed if the application has been designed to invoke parameterized controller constructor and satisfy its dependencies.</li>
						<li>After the controller instance is created the next major step is to find and execute the corresponding action. A component called ActionInvoker finds and executes the action defined in routing table.</li>
						<li>Before the action method is called model bindings takes place which maps data from http request to action method parameters.</li>
						<li>After the model binding, action filters are invoked which includes OnActionExecuting filter.</li>
						<li>This is followed by action execution and Action Executed filter execution and finally preparing Action Result.</li>
						<li>Once the Action method has been finished executing the next step is Result execution. MVC separates the action declaration from Result execution.</li>
						<li>If the Result from action execution is view, then depending upon configuration, ASPX or Razor view engine will be called to find and render the html view as a response of http request. If the result was not view then it’s passed as-is to http response.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img10.png" title=""/></p>
					<h3>Webforms and MVC</h3>
					<ul>
						<li>Service to a request in Web forms life cycle corresponds to serving a physical file on the disk. However this is not the case in MVC. IN MVC, there is not real concept of serving files from the disk, rather Controller action are executed to render a view to the user.</li>
						<li>Despite the differences both the web forms and MVC requests implement through HttpHandler. In web forms each page is derived from IHttpHandler interface and request is served more directly. MVC controllers are also derived from HttpHandlers.</li>
						<li>From a higher level, MVC is just another way to manage request from ASP.net platform. One can create their own pipeline and build a framework like MVC or web forms on their own.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img11.png" title=""/></p>
					<h3>Application Life Cycle</h3>
					<ul>
						<li>MVC application life cycle contains two application level events that are associated with start and end events of the application.</li>
						<li>Application start fires when the application is brought to life by a very first request to the application. Application end event is fired when application has been shut down.</li>
						<li>It’s important to understand application life cycle events to get a better understanding on how MVC life cycle starts. So far we have seen that URL Routing module is the starting point for MVC application that has a collection of predefined routes to map from.</li>
						<li>Now, the question here is how does URL routing handler gets this information from? The answer is simple, using Application start event.</li>
						<li>MVC applications provide these events in Global.asax file which contains all the application level events. All the prestart things are managed in the application start event.</li>
						<li>MVC Application_Start event is:
							<ul>
								<li>An event that fires when first request is received</li>
								<li>Can be used to run initial configuration and settings code</li>
								<li>The event takes care of registering all areas of MVC application, installing global filters, adding routes and bundles</li>
							</ul>
						</li>
					</ul>
					<h3>Register Routes</h3>
						<ul>
							<li>Since Application_start event is the first event that gets called when application receives its very first request, all the pre application tasks like routing takes place here.</li>
						</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img12.png" title=""/></p>
					<h3>PreApplicationStart:</h3>
					<ul>
						<li>PreApplicationStart is another option at the assembly level to register something before the application starts. It could be used to run some initial configuration code or register modules or any other code that needs to be executed before the application starts.</li>
					</ul>
					<h3>HttpHandlers</h3>
					<ul>
						<li>HttpHandlers are classes that implement IHttpHandler and generate a response to HttpRequest. There could be httpHandler re-assignment in a life cycle of a request but only one http handler executes and provides response.</li>
						<li>There are two sets of events in the MVC request life cycle that concerns HttpHandlers, [MapRequestHandler and PostMapRequestHandler] and [RequestHandlerExecute and PostRequestHandlerExecute].</li>
						<li>MapRequestHandler and PostMapRequestHandler are the events in the life cycle which determines the httpHandler responsible for executing the request. Only the selection happens during this time.</li>
						<li>RequestHandlerExecute and PostRequestHandlerExecute are the life cycle events that actually executes the htttp handler determined in the earlier phases of request life cycle.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img13.png" title=""/></p>
					<h3>Creating an HttpHandler</h3>
					<ul>
						<li>Create a class that implements IHttpHandler interface</li>
						<li>Register the HttpHandler through code or web.config</li>
						<li>IHttpHandler exposes two members:
							<ul>
								<li>IsReusable</li>
								<li>ProcessRequest()</li>
								<li>SampleHandler.cs</li>
							</ul>
						</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img14.png" title=""/></p>
					<h3>HTTPModules</h3>
					<ul>
						<li>HttpModules are classes that implement IHttpModule interface and are designed to respond to Life cycle events.</li>
						<li>In a given Http life cycle, multiple http modules can respond to one single request and can also hook into multiple life cycle events.</li>
						<li>So they are not tied to any specific event, rather they can act at several places during the life cycle and expose multiple development possibilities.</li>
						<li>One of the advantage HttpModules bring is the reusability, modules written once can be reused any several application across frameworks.</li>
						<li>Features such as logging and authentication are best examples of wrapping things up in a HttpModule. One can also do the all these things possible in HttpModule in a Global.asax file, but that won’t achieve reusability and abstraction.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img15.png" title=""/></p>
					<h3>Creating a HTTPModule</h3>
					<ul>
						<li>Implement the IHttpModule interface</li>
						<li>Register the HttpModule through code or config</li>
						<li>IHttpModule exposes two members:
							<ul>
								<li>Init ( )</li>
								<li>Dispose ( )</li>
							</ul>
						</li>
					</ul>
					<h3>HttpModule and HttpContext</h3>
					<ul>
						<li>HttpModule and HttpContext work with each other in the life cycle of a request to serve and achieve the goals of a module.</li>
						<li>For instance, HttpModule can populate the user information and populate UserInfo object inside HttpContext for applications read its value and proceed accordingly.</li>
						<li>HttpModules takes advantage of hooking within the lifecycle events, even before the ASP.net MVC framework starts taking control of request. In fact, HttpModules can act early on to request in the very first event itself, “Begin Request”, much before the MVC life cycle takes over.</li>
						<li>This gives HttpModules an edge over MVC requests because you could respond to a request early on and take appropriate actions well before.</li>
						<li>This can have some serious implications, there are certain things which HttpModules can do really better, while avoiding the MVC framework completely.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img16.png" title=""/></p>
					<h3>Comparing HTTPHandlers and HTTPModules</h3>
					<ul>
						<li>Many HttpModules can service one request, however only one HttpHandler can service a request.  </li>
						<li>HpptModules are primarily used to modify and support requests through services, however HttpHandlers are used to generate a response that is sent back to browser using an HttpHandler.</li>
						<li>HpptModules are implemented through IHttpModule interface, and HttpHandlers are implemented through IHttpHandler interface</li>
						<li>Both HttpModule and HttpHandler can be registered through code or config file.</li>
						<li>HttpModules and deigned to integrate with any of the life cycle events, however HttpHandlers are generally concerned with events related to mapping and execution.</li>
					</ul>
					<h3>MVCRouteHandler and MVCHandler</h3>
					<ul>
						<li>UrlRouting module is a special module that contains PostResolveRequestCache event that actually matches the incoming request to routing table and executes routing handler for it.</li>
						<li>Routing handler is simply a class that implements IRouteHandler interface and exposes one method “GetHttpHandler” and return MvcHandler to execute further. MvcHandler is a standard HttpHandler which exposes two methods, IsReusable and ProcessRequest. The ProcessRequest inside the MvcHandler is the entrance into the MvcFramework.</li>
					</ul>
					<h3>Controllers</h3>
					<ul>
						<li>Controllers and actions are the two very important components in MVC that every developer work with. A controller takes care of orchestrating relationships between views and models.</li>
						<li>Controllers are nothing complex but a class that implements IController interface and exposes one method “Execute ()”. This execute method actually kicks the execution of controllers in the request life cycle.</li>
						<li>At a high level, the job of a MvcHandler is to generate a response by executing a controller. But a lot goes under the curtain so let’s try to understand how the controller is selected, instantiated and executed to serve the request.</li>
						<li>MvcHandler doesn’t create an instance of controller right away, rather takes help from several other important classes to perform this.</li>
						<li>MvcHandler first calls a method ProcessRequestInit() which calls a controller factory to select a controller using the route data provided.</li>
						<li>Once the selection is performed by controller factory, Controller Activator creates an instance of requested controller using Dependency Resolver.</li>
						<li>If no dependency resolved was found then Controller Activator manually creates an instance of controller and returns it for execution.</li>
						<li>Once the controller has been initialized MvcHandler calls controller.Execute() method to begin processing execution. Following diagram depicts the control flow.</li>
					</ul>
					<p class="text-center"><img class="img-responsive" src="img/blog/img17.png" title=""/></p>
					<h3>Controller Factory</h3>
					<ul>
						<li>Controller factory is used directly by MvcHandler to get the Controller to execute. Its primary responsibility to find the appropriate type of controller to serve the request.</li>
						<li>At the heart of ControllerFactory is the interface IControllerFactory that a default controller factory implements.</li>
						<li>You could add your own custom factory by implementing IControllerFactory interface. The interface exposes three main methods:
							<ul>
								<li>CreateController for creating controller, it should return a type that implements IController.</li>
								<li>GetControllerSessionStateBehavior determines how session is handled for a given controller.</li>
								<li>ReleaseController for releasing any resources factory is holding onto.,</li>
							</ul>
						</li>
					<li>MVC framework provides a robust controller factory out-of-the box, called as “DefaultControllerFactory”. This default factory handles a lot of low level work for getting and creating an instance of desired controller.</li>
					<li>For instance, if the incoming request is myAPP/Order/22, then controller factory would create an instance of OrderController or whatever is being specified in routing data.</li>
					<li>The default controller also has access to “Dependency Resolver”, which helps in resolving dependencies of controller.</li>
					<li>This is the place where custom dependency resolvers fits in to give way for IoC container to come in and resolve dependencies like parameterized contractors etc.</li>
				</ul>
				<h3>Action Method Execution</h3>
				<ul>
					<li>Once the Controller has been chosen and initialized execution start, this includes choosing an Action using ActionInvoker’s Select method.</li>
					<li>Action invoker selects appropriate method using route data and method names to choose best fit method.</li>
					<li>Once the selection is done, Authentication filters fires to ensure that current user is authenticated. If the authentication fails then a challenge is sent back to the use, which could involve redirect user to a login page.</li>
					<li>If the authentication passes, request moves ahead with authorization. Once again, the same process happens, if the user is not authorized, then a challenge is sent back to browser, otherwise request pipeline moves.</li>
					<li>Once the authentication and authorization are passed, request moves forward with identifying parameters required to pass in to selected action.</li>
					<li>This process is called as Model Binding. Model binding collects data from query string, route data and request to generate objects required by Action method.</li>
					<li>The process correctly maps the parameters to objects and also takes care of converting incoming types to correct types required by Action method.</li>
					<li>Once the model binding has been done, Action filters kick in. before an action method is being called, OnActionExecuting filter is executed and any code placed inside this filter gets executed.</li>
					<li>Once the OnActionExecuting has been executed, Action method execution starts. Once the Action method has been executed and a response has been generated, another filter OnActionExecuted gets executed.</li>
					<li>All the steps involved in Action execution are very much extensible and that makes MVC a great framework to work with.</li>
				</ul>
				<p class="text-center"><img class="img-responsive" src="img/blog/img18.png" title=""/></p>
				<h3>Action Invoker</h3>
				<ul>
					<li>Controller’s execution is really empowered by ActionInvoker’s select method in the sense that it can select appropriate action in variety of ways.</li>
					<li>Like many other MVC framework components Action Invoker also implements a simple interface “IActionInvoker” that exposes one method InvokeAction.</li>
				</ul>
				<p class="text-center"><img class="img-responsive" src="img/blog/img19.png" title=""/></p>
				<ul>
					<li>The method takes two arguments, controllerContext and actionName that are used to select and invoke appropriate action.</li>
					<li>In almost all the cases you don’t need to implement this interface because MVC by default provides a powerful implementation, ControllerActionInvoker. Further, default behaviour of controller action invoker can be customized using extension points.</li>
				</ul>
				<h3>Action Selectors</h3>
				<ul>
					<li>Action Selectors select an action based on Route Data and matches the method name. Sounds simple, but there is more to it. If you have worked with Http methods before, you might recognize that MVC provides Action methods with http attributes.</li>
					<li>One can decorate action methods with these http attributes to specify how this method should be invoked. For example, it ensure that a http GET request can’t invoke http POST method, just because the name matches.</li>
					<li>Some common Action selectors that MVC provides are HttpGet, HttpPost, AcceptVerbs, ActionName, NonAction and Custom</li>
					<li>Selecting an action is a multi-step process. First off, MVC determines which methods are eligible, only public non-static, non-special methods (e.g. constructors, ToString() are excluded) are considered in the Action method selection. Then, the framework matches signature of the methods with incoming request.
						<ul>
							<li>If any valid method, with signatures matches to only one method then that method is returned otherwise No Match error is thrown. </li>
							<li>If there are multiple methods found with same signature then only one where action selectors matches is returned otherwise No Match error is thrown. </li>
							<li>If there are multiple methods with same action selectors then Ambiguous Match error is thrown.</li>
						</ul>
					</li>
				</ul>
				<p class="text-center"><img class="img-responsive" src="img/blog/img20.png" title=""/></p>
				<h3>Filters</h3>
				<ul>
					<li>Filters are designed to inject logic in between MVC request life cycle. Filters provide users with powerful ways to inspect, analyze, capture and instruments several things going around within MVC projects.</li>
					<li>A very interesting thing that how filters run at multiple points in the request life cycle compared to other components. As of MVC5, there are 5 types of filters.</li>
				</ul>
				<p class="text-center"><img class="img-responsive" src="img/blog/img21.png" title=""/></p>
				<ul>
					<li>Authentication filters are new addition from MVC 5. These filters kick in first in the request life cycle and perform the authentication logic.</li>
					<li>Authorization filters are executed after the Authentication filters successfully executed and authorizes users roles to ensure current user has access to request resource.</li>
					<li>Action filters are executed next in the request life cycle and execute any custom logic you may want to perform before and after action execution.</li>
					<li>Result filters are executed before and after result execution.</li>
					<li>Finally, the exception filters are executed when there is an exception during processing of request.</li>
				</ul>
				<h3>Scope of Filters</h3>
				<p>Filters can be applied to specific actions and it will run for only those specified actions. Next, filters could also be decorated at the controller level, so it run for all the action of that controller. Finally, we could also specify filters to run at a global level for all the controllers and actions.</p>
				<h3>Action Result Execution</h3>
				<ul>
					<li>The journey of MVC life cycle ends with Action result execution. It’s the last and final step in MVC request life cycle. It’s also the most important one, because this is where result is sent back to browser.</li>
					<li>Action result execution starts after action invoker are identified an action to execute. At this point, first the Result Filters are executed before and after actual result execution.</li>
					<li>OnResultExecuting filter executes first in the sequence, followed by Action Result – ExecuteResult(), which takes care of executing result.</li>
					<li>At this point the further execution could branches in to two separate routes. If the result type is View Engine then appropriate view engine Razor or ASPX is brought in to render partial view or view.</li>
					<li>At the same time, if the Response is any other type, then response if directly written without bringing view engine altogether.</li>
					<li>Finally, ResultFilter “OnResultExecuted” is executed which could perform any custom logic written in this filter. Generally speaking, this is the last point in the MVC request life cycle to inject your custom code into the life cycle.</li>
				</ul>
				<p class="text-center"><img class="img-responsive" src="img/blog/img22.png" title=""/></p>
				<p class="text-center"><img class="img-responsive" src="img/blog/img23.png" title=""/></p>
				<h3>View Results and View Engine</h3>
				<ul>
					<li>View results are the most common results type that as a MVC developer you might be using. On a high level, View result is responsible for returning HTML back to your browser.</li>
					<li>View Result employs View Engine to do this task and ensures the correct views are being rendered.</li>
					<li>There are two view engines that MVC provides by default, Razor View Engine and Legacy View Engine. Razor view engine is more sophisticated and fast compared to Legacy engine. Legacy view engine understands ASPX format code and emits raw HTML.</li>
					<li>View rendering process starts when the View Result calls the Execute Result method from its base class ViewResultBase.</li>
					<li>The ExecuteResult from viewResultBase calls the abstract method FindView. The child view result overrides this method and calls FindView from view engine, which either returns a view or list of locations searched to locate a view.</li>
					<li>Finally ViewEngineResult returns a view which has single method “Render” which actually writes response to the request. Following is the diagram that depicts this flow.</li>
				</ul>
				<p class="text-center"><img class="img-responsive" src="img/blog/img24.png" title=""/></p>
				<ul>
					<li>If we look at ViewEngine, which actually implements IViewEngine interface and exposes three methods, FindView, FIndPartialView and ReleaseView.</li>
					<li>First two methods which deals with finding view are important to search and locate view and return it for processing. ReleaseView method simply releases any resources holding by viewengine like FileStream</li>
				</ul>
				<h3>Default Razor Search Locations</h3>
				<p>Once the view has been found viewengine calls its render method to emit html code for browser to display on the screen.</p>
				<p class="text-center"><img class="img-responsive text-center" src="img/blog/img25.png" title=""/></p>

                </div>
            </div>
        </div> <!-- container  -->

        <aside id="footer-widgets">
            <div class="container">
                <div class="row">
                    <div class="col-md-4">
                        <h3 class="footer-widget-title">Sitemap</h3>
                        <ul class="list-unstyled three_cols">
                            <li><a href="#">Home</a></li>
                            <li><a href="#">About Us</a></li>
                            <li><a href="#">Courses</a></li>
                            <li><a href="#">New Batches</a></li>
                            <li><a href="#">Contact</a></li>
                        </ul>
                    </div>
                    <div class="col-md-4">
                        <div class="footer-widget">
                            <h3 class="footer-widget-title"> </h3>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="footer-widget">
                            <h3 class="footer-widget-title"> </h3>

                        </div>
                    </div>
                </div> <!-- row -->
            </div> <!-- container -->
        </aside> <!-- footer-widgets -->

        <footer id="footer">
            <p>&copy; 2016 <a href="#">Sri IT Solutions</a>, inc. All rights reserved.</p>
        </footer>

    </div> <!-- boxed -->

    <div id="back-top">
        <a href="#header"><i class="fa fa-chevron-up"></i></a>
    </div>


    <!-- Scripts -->
    <script src="js/jquery-1.10.2.min.js"></script>
    <script src="js/jquery.cookie.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/jquery.mixitup.min.js"></script>
    <script src="js/lightbox-2.6.min.js"></script>
    <script src="js/holder.js"></script>
    <script src="js/app.js"></script>
    <script src="js/styleswitcher.js"></script>
    <script src="js/syntax/shCore.js"></script>
    <script src="js/syntax/shBrushXml.js"></script>
    <script src="js/syntax/shBrushJScript.js"></script>

    <script type="text/javascript">
        SyntaxHighlighter.all()
    </script>
</body>
</html>
